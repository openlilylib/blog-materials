\documentclass{article}

\usepackage{color}

\usepackage[a4paper, top=2.5cm, bottom=2.5cm, left=2.5cm, right=2.5cm]{geometry}

\usepackage{pdfpages}

\begin{document}
\title{Composing Music Algorithmically}
\author{Gilberto Agostinho}
\date{}
\maketitle

As pointed out in previous posts by Urs Liska \textcolor{red}{[links to "Plain Text Files in Music" and
"Programmatically Generating LilyPond Input"]}, a music engraving program that is based on plain text has
the potential to be programmatically controlled by the user, which is a big attraction for an algorithmic
composer such as myself. 
There are numerous ways of manipulating plain text files, and this can be done by using virtually any
programming language one might know. 
With LilyPond it is possible to programatically write a score by directly inputting a mixture
of regular LilyPond code and code written in its extension language, Scheme; another popular choice is to
use Python, together with dedicated packages such as Abjad \textcolor{red}{[link to its website]}. 
In my case though, I have chosen to do all my work using Fortran 95.

I use Fortran for a very simple reason: before studying music, I studied physics for a couple of years,
where all my programming projects had to be written in Fortran. 
Even with all its limitations, I still see Fortran as a very powerful language, particularly when dealing
with purely mathematical calculations (something that I use constantly in my compositions). 
And then, during the last months, I have been writing a library of subroutines for Fortran which produce
LilyPond input and allow me to algorithmically generate a complete .LY file.

Due to both my wish to experiment with my library and my interest in gradual processes in music,
I decided to implement Steve Reich's \textit{Clapping Music} \textcolor{red}{[link to some performance
at Youtube maybe?!]}. 
For those whom are not familiar with this composition, it strictly follows a very simple algorithm: take a pattern
of claps and rests of length $N$ (in eighth notes). 
Player 1 will play this pattern in its original form for $N^2+N$ times. 
Player 2 will play the original pattern for $N$ times; after this, the pattern will have all its notes
shifted by $-1$ beat (i.e., all notes move one beat to the left, and the first note becomes the last)
and then it will be repeated for another $N$ times; 
after this, the current pattern will once again shift by $-1$ beat and be repeated for another $N$ times. 
This process is repeated until the two patterns coincide once again, then they are repeated for another $N$
times before ending the work (this procedure is related to Reich's ideas of simultaneously playing a pattern
at different speed, applied in works such as \textit{Piano Phases}).

It is very important to note that Reich's composition consists of a single score with a specific chosen pattern:

\includegraphics{ClappingMusicSmall.pdf}

Therefore, he did not authored the process behind it, but rather its specific musical result. 
This is a very important distinction to make; compare this to \textit{I Am Sitting in a Room}
\textcolor{red}{[link to Youtube once again?]}, by Alvin Lucier. 
In this work, Lucier blurs the difference between a \textit{composition} and a \textit{process} by allowing
the interpreter to read out loud any text in any room (so, unlike Reich, he does not authors a specific
\textit{pattern}). 

While implementing Reich's score with his own pattern, I thought that it could be interesting to generalize
his algorithm, so that the user could input any pattern of claps and rests, of any length, and get his score
automatically generated in front of him. 
The result of this little experiment is the present program I wrote. 
In pseudo code (Fortran style), Reich's algorithm looks like this:

\begin{verbatim}
read N ! input of the number of eighth notes per bar
do i=1,N
  read pattern(i) ! input of a pattern, using 1 as clap and 0 as rest
enddo

! Code for player 1
do i=1,(N+1)
  do j=1,N
    if (pattern(j)==1) clap
    if (pattern(j)==0) rest
  enddo
enddo

! code for player 2
do i=1,(N+1)
  do j=1,N

    ! shift of positions
    aux=MOD((j+i-1),N)
    if (aux==0) aux=N

    if (pattern(aux)==1) clap
    if (pattern(aux)==0) rest

  enddo
enddo
\end{verbatim}

Here is an example of a score generated by my program with a pattern of 5 notes ($N=5$). 
The pattern used is clap, clap, rest, clap, rest (or 11010 in binary notation, considering claps as 1 and rests
as 0).

\includegraphics{Ex1Small.pdf}

\textcolor{red}{[would it be possible to add a link for the complete .PDF file and its .LY code here?!
I think that could be interesting for the readers]}

Compare this previous example to another one, this time with the pattern 100110110 ($N=9$).

\includegraphics{Ex2Small.pdf}

\textcolor{red}{[another link for the .PDF and .LY files]}

I then decided to add still one more option to my program: to produce a random score, with a random $N$ varying
between 3 and 15 and with a random pattern. 
Here is an example of it:

\includegraphics{Ex3Small.pdf}

\textcolor{red}{[and still another link for the .PDF and .LY files]} 

This is just a very simple example of what can be done via programming and LilyPond. 
As a more complex example, consider Pierre Boulez's \textit{Structures Ia}, arguably the best known example of 
integral serialism. All its complex procedures could be implemented algorithmically via a computer, and thus it 
could also be generalized for any series of $N$ sounds. Unfortunately it is not possible to generate this score 
in the same manner as I did with Reich's composition, due to the fact that \textit{Structures Ia} is not completely 
automatized (Boulez's took several personal decisions regarding the registers, for instance). But by using a random 
algorithm to generate registers, it is possible to achieve a very consistent result.

My own work as a composer is based on this concept of a generalized algorithm: 
having been influenced by the automation of the integral serialism, by Iannis Xenakis' use of probability and
computers (mainly as a calculator on his case) and by composers that think of music as a process (such as Steve
Reich and also the spectral composers), nowadays I consider that the act of composing cannot be distinguished from
the act of creating and organizing generative musical procedures. 
It is as if one would create the laws that governs a hypothetical world, and then let this world evolve by
itself (with the help of stochastic events, for instance). 
Lately, my main interest is to produce music that renews itself at every performance, be it electronic,
be it acoustic. 
Using LilyPond together with Fortran has just allowed me that.

I would like to finish this short text by quoting Brian Eno:

\textit{I really think it is possible that our grandchildren will look at us in wonder and say:
"You mean you used to listen to exactly the same thing over and over again?"}

\end{document} 
